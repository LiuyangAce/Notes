1.函数
    1）函数的介绍
        1.封装具有某些特殊功能的代码
            数组去重
            防抖、节流
            jQuery
            ...
        2.封装对象创建的过程【高级面向对象 构造函数】
    2）创建方式
        1.函数表达式
            var 函数名 = function(形参) {
                //函数体
            }
        2.函数声明
            function 函数名字(形参) {
                //函数体
            }
    3）函数的调用
        一般情况下，函数创建完成之后，函数体中的代码不会执行
        【立即执行函数】不需要调用，就可以执行函数体的代码。
        1.函数名(实参)
        2.函数名.call(this,实参列表) (this,'tom',13,...)
        3.函数名.apply(this,实参数组) (this,['tom',13])
        4.函数名.bind()

        拓展：
        1.函数在访问时,加不加小括号的区别
            function sayHello(){
        console.log('hello');
            }
            var a = sayHello();
            var obj = {
                    say:a
            }
            console.log(obj);//hello {say:underfined}

            如果加上了()表示调用函数，也就是执行完函数体的代码之后，再将函数的返回值符赋值某个变量，如果不加
            （），表示访问函数的引用地址，指向堆区中函数，并不会执行函数体的代码。
        2.函数返回值：return和console.log();的区别；
            console.log()仅仅表示打印一个结果，并不是函数的返回值
            return才是函数的返回值，一般情况下，想要知道函数有没有返回值，看看函数中由没有return关键字即可
                特殊情况：自定义构造函数
        3.变量提升
            变量声明和函数声明【函数声明的优先级比变量声明的优先级更高】，
            在js进行解析文件时，会被提升到当前作用域的最顶端
                作用域：
                    当前js文件
                    函数的最顶端
    4）函数的内部属性
        只有当函数运行时才能确定的属性
        1.形参
            函数接收实参时使用的
        2.arguments
            函数存储参数的地方
                function say(name,age){
                    console.log(name,age);
                    console.log(arguments);
                }
                say('tom',13,'male');//tom 13 
                [Arguments] { '0': 'tom', '1': 13, '2': 'male' }
        3.this上下文对象
            this的指向取决于函数调用的方式：四种
            情况一：
                var obj = {
                    name:'tom',
                    sayName:function(){
                        console.log(this.name);
                    }
                };
                obj.sayName();//tom
            情况二：
                function sayName(){
                    console.log(this);
                }
                sayName();//global 全局变量
            结论一：
                函数在调用时，左侧有没有对象
                    有
                        this指向该对象【this等于该对象】
                    没有
                        this指向全局对象
                            nodejs -> global对象
                            浏览器 -> windows对象

            情况三：
            var dog = {
                    word:'汪汪',
                    sound:function(){
                            console.log(this.word);
                    }
            }
            dog.sound();//汪汪

            var yw = {
                    sound:function(){
                            console.log(this.word);
                    }
            }
            //通过call，将原本指向yw对象的this，更改为指向dog对象
            yw.sound.call(dog);//汪汪
            结论二：如果函数调用时使用了call，apply，bind方式，则this指向的是更改后的对象。

            结论三：箭头函数中this指向的是该箭头函数外部函数的this
    5）匿名函数、立即执行函数
        匿名函数：没有名字的函数
        立即执行函数：函数创建完成后，会自动执行函数体的代码。

        匿名函数使用场景
            作为其他函数的参数
                var arr = [1,2,3,4];
                arr.forEach(function(item,index){
                        console.log(item,index);
                });
        立即执行函数一般结合匿名函数的使用
            (function(a,b){
                console.log(a+b);
            })(1,3); //4

    6）闭包
        函数内部嵌套函数，内部函数访问外部函数中的变量

            function p1(){
                    var name = 'tom';
                    function p2(){
                            var age = 13;
                            console.log(name);
                    }
                    p2();
            }
            p1();//tom
            也就是p2函数可以访问到p1函数中的name变量

            错误写法：
            function p1(){
                    var name = 'tom';
                    console.log(age);
                    function p2(){
                            var age = 13;
                            console.log(name);
                    }
                    p2();
            }
            p1();
            //报错，age is not defined。
            也就是p1函数无法访问p2函数中的变量
            拓展：(1) 闭包会产生什么问题
                  会造成内存泄漏，也就是说正常情况下，js会将使用过的变量通过垃圾回收器进行回收(释放内存)
                  我们使用闭包后，会使得外部函数中的变量无法被垃圾回收器回收。
                  (2) 闭包的使用场景
                    1.作为其他函数的参数
                    2.可以实现防抖、节流
                    ...
            ---面试题---
            1.call、apply、bind的区别
                这三种方式都是为了更改this的指向
                参数
                    call、bind在传递实参时候，使用的是参数列表
                    apply在 使用的是参数数组
                调用
                    call、apply在更改this时，可以直接调用函数
                    bind在更改this时候，不可以自动调用函数，需要手动再次调用函数。
            2.如何实现call、apply、bind（用自己的代码）【了解】
    
            
